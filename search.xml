<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android Studio 3.0遇到的坑]]></title>
    <url>%2F2018%2F03%2F31%2Fandroid%2FAndroidStudio3%2F</url>
    <content type="text"><![CDATA[转自吴小龙同学 原文链接： http://wuxiaolong.me/2017/11/04/AndroidStudio3/ 前几天，期待已久的 Android Studio 3.0 release 版来临了，根据以往经验，每次大版本升级肯定要折腾一番，况且公司最近项目紧，因此我没有着急升级。10 月 31 号项目交了第一个版本，有同事离职了，我接了 NDK 的锅，到现在终于有空了，手痒痒点了升级。Android Studio 3.0官方更新日志：https://developer.android.google.cn/studio/releases/index.html ，我截图了，用的 Chrome 自带翻译功能，有些翻译不到位，但比我这半吊子英语看省事多了。增量升级点击 Check for Updates 增量更新：下载完成，会提示更新 您将 Gradle 更新至 4.1：这里建议您对老项目先暂时点击 Don’t remind me on this project，以防有坑。当然我不入地狱谁入地狱，我点 Update，于是问题来了，一直处于下载中，不过，莫担心，我下载好了，公众号聊天界面回复「gradle-4.1-all」，下载 gradle-4.1-all.zip 文件，放到：重启 Android Studio。gradle 目录：Mac系统默认：/Users/(用户名)/.gradleWindows系统默认：C:\Users(用户名).gradle修改旧项目首先我们新建项目，看看发生了哪些变化。1、app／build.gradlebuildToolsVersion：这里没有构建工具的版本 buildToolsVersion 属性了，Android Studio 3.0 默认情况下，插件会自动为您使用的 Android 插件版本使用最低要求的构建工具版本；implementation：由以前的 compile 改成了 implementation。老版本的构建关键字 compile 被废弃了，而是改成了这两个：api：同 compile 作用一样，即认为本 module 将会泄露其依赖的 module 的内容；implementation：本 module 不会通过自身的接口向外部暴露其依赖 module 的内容。2、项目 build.gradlegoogle()：Android Studio 3.0 现在默认使用 Google 的 Maven 存储库，而不是依赖于 Android SDK Manager 来获取 Android 支持库，Google Play 服务，Firebase 和其他依赖项的更新；build.gradle：指定的是Gradle插件的版本，由之前的 2.3.3 改成了 3.0.0。3、gradle-wrapper.propertiesgradle-wrapper.properties 中配置的是的 Gradle 的版本。可以对老项目就以上几点进行修改。butterknife如果您在 lib 里使用了 butterknife，会遇到以下错误：网上说将 apply plugin: ‘com.jakewharton.butterknife’ 注掉，是能解决问题，但是对于 lib 里使用了 butterknife 依旧报 R2 找不到，还得放开 apply plugin: ‘com.jakewharton.butterknife’，最后我只能退而求其次，将 build.gradle 中 3.0.0 改成之前的 2.3.3，解决。打包自定义 APK 文件名打包时，要是自定义输出 APK 文件名可以这样做：12345678910111213141516171819202122android { buildTypes { release { //…… applicationVariants.all { variant -&gt; if (variant.buildType.name == ‘release’) { variant.outputs.each { output -&gt; def outputFile = output.outputFile if (outputFile != null &amp;&amp; outputFile.name.endsWith(‘.apk’)) { def fileName = “Sample_v${defaultConfig.versionName}${releaseTime()}${variant.flavorName}.apk” output.outputFile = new File(outputFile.parent, fileName) } } } } } }}def releaseTime() { return new Date().format(“yyyy-MM-dd”, TimeZone.getTimeZone(“UTC”))}使用 Gradle Plugin 3.0.0 时报错：12Cannot set the value of read-only property ‘outputFile’ for ApkVariantOutputImpl_Decorated{apkData=Main{type=MAIN, fullName=release, filters=[]}} of type com.android.build.gradle.internal.api.ApkVariantOutputImpl. Open File需要修改 each() 和 outputFile() 方法为 all() 和 outputFileName，输出文件写法也有点不一样：12345678910111213141516buildTypes { release { //…… applicationVariants.all { variant -&gt; if (variant.buildType.name == ‘release’) { variant.outputs.all { def apkName = “gradle4android_v${variant.versionName}” if (!variant.flavorName.isEmpty()) { apkName += “${variant.flavorName}” } outputFileName = apkName + “${releaseTime()}.apk” } } } }}输出的路径也有点不一样，根目录是 release，如果有渠道 xiaomi，那根目录是 xiaomi／release。style attribute ‘@android:attr/windowEnterAnimation’ not found.1234Error:(22, 5) style attribute ‘@android:attr/windowEnterAnimation’ not foundError:(22, 5) style attribute ‘@android:attr/windowExitAnimation’ not foundError:(31, 5) style attribute ‘@android:attr/windowEnterAnimation’ not foundError:(31, 5) style attribute ‘@android:attr/windowExitAnimation’ not found这是aapt2导致的，3.0默认启用了aapt2。解决办法：在project的根目录下的gradle.properties最后添加关闭aapt2的代码：1android.enableAapt2=false补充build.gradle 和 gradle-wrapper.properties 区别，了解更多：https://developer.android.com/studio/releases/gradle-plugin.html最后目前遇到这些坑，欢迎一起吐槽您在升级开发遇到的坑，这次升级又折腾了很久。另外如果需要gradle-4.1-all.zip 文件，公众号「吴小龙同学」聊天界面回复「gradle-4.1-all」获取。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 命令行常用命令]]></title>
    <url>%2F2018%2F03%2F31%2Fgit%2Fgit%2F</url>
    <content type="text"><![CDATA[git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。公司目前的代码管理用的是git,自己简单总结了下git常用的命令。 命令行总结高手都是直接用命令行，用命令行显得逼格更高。 用户信息第一个要配置的是你个人的用户名称和电子邮件地址。这两条配置很重要，每次 Git 提交时都会引用这两条信息，说明是谁提交了更新，所以会随更新内容一起被永久纳入历史记录： git config --global user.name &quot;xxxx&quot; #用户名 git config --global user.email &quot;xxxx@xxx.com&quot; #邮箱 检出仓库git clone git://github.com/jquery/git_learn.git 查看分支查看本地所有分支 git branch 查看远程所有分支 git branch -r 列出所有本地分支和远程分支 git branch -a 创建本地 dev 分支git checkout -b dev 创建新分支dev并立即切换到新分支，相当于以下两条命令： git branch dev git checkout dev git checkout -b local-branchname origin/remote_branchname 就可以将远程分支映射到本地命名为local-branchname 的一分支,如：想从远程分支 dev （远程有该分支）创建本地分支 dev1： git checkout -b dev1 origin/dev 开发提交add 文件 git add README.md 添加所有修改的文件 git add . commit 本地提交 git commit -m &quot;修改的内容&quot; 将文件给推到服务器上 git push -u origin master 合并到本地 master 分支合并到本地 master 分支分支 dev 开发工作完成，我们就可以切换回本地 master 分支 git checkout master 进行本地分支 dev 合并 git merge dev 删除本地分支git branch -d dev -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项 git branch -D dev 创建远程分支 dev直接提交 git push origin master:dev 这里冒号可以提交到指定分支，上面命令，把提交本地 master 分支到远程的 dev 分支，远程没有dev这个分支，会创建。 git push origin master 这是本地 master 提交到远程主分支 master，相当于： git push origin master:master 删除远程分支git push origin --delete dev 或者 git push origin :dev 远程分支 dev 将被删除。 删除一个文件git rm [file name] 回到具体的版本git reflog 查看命令历史，以便回到具体的版本 git reset --hard HEAD^ git pull 和 git fetch 的区别git pull 本地与服务器端同步 git fetch 相当于是从远程获取最新版本到本地，不会自动merge 如：git fetch origin master(更新分支，未何并) git merge master 参考常用 Git 命令清单Git分支管理策略]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分享多张图片到微信朋友圈]]></title>
    <url>%2F2018%2F03%2F11%2Fandroid%2Fshare%2F</url>
    <content type="text"><![CDATA[分享核心代码/** *content: 朋友圈的文字内容 *uris: 图片的集合 */ private void shareToWX(Activity activity,String content, ArrayList&lt;Uri&gt; uris){ try { Intent intent = new Intent(); ComponentName comp = new ComponentName(&quot;com.tencent.mm&quot;, &quot;com.tencent.mm.ui.tools.ShareToTimeLineUI&quot;); intent.setComponent(comp); intent.setAction(Intent.ACTION_SEND_MULTIPLE); intent.setType(&quot;image/*&quot;); intent.putExtra(&quot;Kdescription&quot;, content); intent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, uris); activity.startActivityForResult(intent, 10); } catch (ActivityNotFoundException e) { activity.runOnUiThread(new Runnable() { @Override public void run() { Toast.makeText(activity, &quot;您还未安装微信&quot;, Toast.LENGTH_SHORT).show(); } }); } } 7.0获取Uri代码if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) { return FileProvider.getUriForFile(context, &quot;{你的包名}.fileprovider&quot;, file); } else { return Uri.fromFile(file); } //备注：file : File 类型的对象 [也可在7.0以后的版本中获取Uri] try { return Uri.parse(android.provider.MediaStore.Images.Media.insertImage(context.getContentResolver(), file.getAbsolutePath(), file.getName(), null)); } catch (FileNotFoundException e) { e.printStackTrace(); } AndroidManifest.xml&lt;/application&gt; ... &lt;provider android:name=&quot;android.support.v4.content.FileProvider&quot; android:authorities=&quot;{applicationId}.fileprovider&quot; android:exported=&quot;false&quot; android:grantUriPermissions=&quot;true&quot;&gt; &lt;meta-data android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot; android:resource=&quot;@xml/file_provider_paths&quot; /&gt; &lt;/provider&gt; &lt;/application&gt; file_provider_paths.xml (res目录下创建xml文件夹)&lt;files-path&gt; 共享app内部的存储(等价于 Context.getFilesDir() 返回的内容) &lt;files-path name=&quot;name&quot; path=&quot;path&quot; /&gt; &lt;cache-path&gt; 共享内部缓存目录(等价于 getCacheDir() 返回的内容) &lt;cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt; &lt;external-path&gt; 共享外部的存储(等价于 Environment.getExternalStorageDirectory() 返回的内容) &lt;external-path name=&quot;name&quot; path=&quot;path&quot; /&gt; &lt;external-files-path&gt; 共享外部存储中与你的应用关联的目录(等于 Context.getExternalFilesDir(String) 或 Context.getExternalFilesDir(null) 返回的内容) &lt;external-files-path name=&quot;name&quot; path=&quot;path&quot; /&gt; &lt;external-cache-path&gt; 共享外部存储中与你的应用关联的缓存目录(等价于 Context.getExternalCacheDir() 返回的内容) &lt;external-cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt; ##关于属性 name=&quot;name&quot; 引号里的内容可以随便填，建议填有意义的内容。 path=&quot;path&quot; path属性的值表示共享的具体路径。注意：path属性里指定的是路径，而不是某个特定文件。这里不能指定为一个文件，也不能用通配符指定为一组文件 授权//临时授权 intent.setFlags(FLAG_GRANT_READ_URI_PERMISSION 或 FLAG_GRANT_WRITE_URI_PERMISSION);]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>share</tag>
      </tags>
  </entry>
</search>
